use crate::{
    parser::Context,
    ir::{
        types::{self, Type, ArrayType, FunctionType},
        util::unescape,
        module::{
            attributes::Attribute,
            linkage::Linkage,
            visibility::Visibility,
            unnamed_addr::UnnamedAddr,
            global_variable::GlobalVariable,
            preemption_specifier::PreemptionSpecifier,
            name::Name
        }
    }
};

grammar(ctx: &mut Context);

// Module

pub Module: () = {
    <x:ModuleSub *> => {
      ()
    }
};

ModuleSub: () = {
    "source_filename" "=" <name:StringLiteral> => ctx.module.source_filename = name,
    "target" "datalayout" "=" <dl:StringLiteral> => ctx.module.target.datalayout = dl.into(),
    "target" "triple" "=" <tr:StringLiteral> => ctx.module.target.triple = tr.into(),
    <attr_group:AttributeGroup> => { ctx.module.attributes.insert(attr_group.0, attr_group.1); },
    <name:LocalTypeName> "=" "type" <t:Type> =>
        ctx.module.types.base_mut().change_to_named_type(t, name.1),
    <name:GlobalName> "=" <linkage:Linkage?> <preemption_specifier:PreemptionSpecifier?>
        <visibility:Visibility?> <unnamed_addr:UnnamedAddr?> <kind:r"global|constant">
        <ty:Type> <align:CommaAlign?>
        => {
            ctx.module.global_variables.insert(name.clone(), GlobalVariable {
                name,
                linkage,
                preemption_specifier,
                visibility,
                unnamed_addr,
                ty,
                init: None,
                is_constant: kind == "constant",
                align: align.unwrap_or(0),
            });
        },
};

// Types

Type: Type = {
    <t:Type> "*" => ctx.module.types.base_mut().pointer(t),
    "[" <n:r"[0-9]+"> "x" <t:Type> "]" =>
        ctx.module.types.base_mut().array(ArrayType::new(t, n.parse().unwrap())),
    "{" <mut t:(<Type> ",") *> <e:Type?> "}" =>
        ctx.module.types.base_mut().anonymous_struct({
            if let Some(e) = e { t.push(e); }
            t
        }, false),
    "<{" <mut t:(<Type> ",") *> <e:Type?> "}>" =>
        ctx.module.types.base_mut().anonymous_struct({
            if let Some(e) = e { t.push(e); }
            t
        }, true),
    "opaque" => ctx.module.types.base_mut().anonymous_struct(vec![], false),
    <t:Type> <p:FuncTypeParams> => ctx.module.types.base_mut().function(FunctionType::new(t, p.0, p.1)),
    <t:LocalTypeName> => t.0,
    <t:PrimitiveType> => t,
};

FuncTypeParams: (Vec<Type>, bool) = {
    "(" <mut t:(<Type> ",") *> <e:Type?> ")" => {
        if let Some(e) = e { t.push(e); }
        (t, false)
    },
    "(" <t:(<Type> ",") *> <e:"..."> ")" => {
        (t, true)
    }
};

PrimitiveType: Type = {
    "metadata" => ctx.module.types.metadata(),
    "void" => types::VOID,
    "i64" => types::I64,
    "i32" => types::I32,
    "i16" => types::I16,
    "i8" => types::I8,
    "i1" => types::I1,
};

// Names

LocalName: Name = {
    <s:r#"%".*""#> => Name::Name(unescape(s.trim_start_matches("%\"").trim_end_matches("\"")).unwrap()),
    <s:r#"%[a-zA-Z][a-zA-Z0-9\._]*"#> => Name::Name(s.trim_start_matches('%').to_owned()),
    <s:r#"%[0-9]+"#> => Name::Number(s.trim_start_matches('%').parse().unwrap()),
};

GlobalName: Name = {
    <s:r#"@".*""#> => Name::Name(unescape(s.trim_start_matches("@\"").trim_end_matches("\"")).unwrap()),
    <s:r#"@[a-zA-Z][a-zA-Z0-9\._]*"#> => Name::Name(s.trim_start_matches('@').to_owned()),
    <s:r#"@[0-9]+"#> => Name::Number(s.trim_start_matches('@').parse().unwrap()),
};

LocalTypeName: (Type, Name) = {
    <name:LocalName> => {
        let ty = ctx.module.types.base_mut().empty_named_type(name.clone());
        (ty, name)
    }
};

// Linkage

Linkage: Linkage = {
    "private"              => Linkage::Private,
    "internal"             => Linkage::Internal,
    "external"             => Linkage::External,
    "externalweak"         => Linkage::ExternalWeak,
    "availableexternally"  => Linkage::AvailableExternally,
    "linkonce_any"         => Linkage::LinkOnceAny,
    "linkonce_odr"         => Linkage::LinkOnceODR,
    "linkonce_odrautohide" => Linkage::LinkOnceODRAutoHide,
    "weakany"              => Linkage::WeakAny,
    "weakodr"              => Linkage::WeakODR,
    "common"               => Linkage::Common,
    "appending"            => Linkage::Appending,
    "dllimport"            => Linkage::DLLImport,
    "dllexport"            => Linkage::DLLExport,
    "ghost"                => Linkage::Ghost,
    "linkerprivate"        => Linkage::LinkerPrivate,
    "linkerprivateweak"    => Linkage::LinkerPrivateWeak,
};

// PreemptionSpecifier

PreemptionSpecifier: PreemptionSpecifier = {
    "dso_local" => PreemptionSpecifier::DsoLocal,
    "dso_preemptable" => PreemptionSpecifier::DsoPreemptable,
};

// Visibility

Visibility: Visibility ={
    "default" => Visibility::Default,
    "hidden" => Visibility::Hidden,
    "protected" => Visibility::Protected,
};

// UnnamedAddr

UnnamedAddr: UnnamedAddr = {
    "local_unnamed_addr" => UnnamedAddr::Local,
    "unnamed_addr" => UnnamedAddr::Global,
};

// Attributes

AttributeGroup: (u32, Vec<Attribute>) = {
    "attributes" <id:r"#[0-9]+"> "=" "{" <attrs:Attribute *> "}" =>
        (id.trim_start_matches('#').parse().unwrap(), attrs)
};

Attribute: Attribute = {
    "alwaysinline"                => Attribute::AlwaysInline,
    "builtin"                     => Attribute::Builtin,
    "cold"                        => Attribute::Cold,
    "convergent"                  => Attribute::Convergent,
    "inaccessiblememonly"         => Attribute::InaccessibleMemOnly,
    "inaccessiblememorargmemonly" => Attribute::InaccessibleMemOrArgMemOnly,
    "inlinehint"                  => Attribute::InlineHint,
    "jumptable"                   => Attribute::JumpTable,
    "minimizesize"                => Attribute::MinimizeSize,
    "mustprogress"                => Attribute::MustProgress,
    "naked"                       => Attribute::Naked,
    "nobuiltin"                   => Attribute::NoBuiltin,
    "nocfcheck"                   => Attribute::NoCFCheck,
    "noduplicate"                 => Attribute::NoDuplicate,
    "nofree"                      => Attribute::NoFree,
    "noimplicitfloat"             => Attribute::NoImplicitFloat,
    "noinline"                    => Attribute::NoInline,
    "nonlazybind"                 => Attribute::NonLazyBind,
    "noredzone"                   => Attribute::NoRedZone,
    "noreturn"                    => Attribute::NoReturn,
    "norecurse"                   => Attribute::NoRecurse,
    "willreturn"                  => Attribute::WillReturn,
    "returnstwice"                => Attribute::ReturnsTwice,
    "nosync"                      => Attribute::NoSync,
    "nounwind"                    => Attribute::NoUnwind,
    "optforfuzzing"               => Attribute::OptForFuzzing,
    "optnone"                     => Attribute::OptNone,
    "optsize"                     => Attribute::OptSize,
    "readnone"                    => Attribute::ReadNone,
    "readonly"                    => Attribute::ReadOnly,
    "writeonly"                   => Attribute::WriteOnly,
    "argmemonly"                  => Attribute::ArgMemOnly,
    "safestack"                   => Attribute::SafeStack,
    "sanitizeaddress"             => Attribute::SanitizeAddress,
    "sanitizememory"              => Attribute::SanitizeMemory,
    "sanitizethread"              => Attribute::SanitizeThread,
    "sanitizehwaddress"           => Attribute::SanitizeHWAddress,
    "sanitizememtag"              => Attribute::SanitizeMemTag,
    "shadowcallstack"             => Attribute::ShadowCallStack,
    "speculativeloadhardening"    => Attribute::SpeculativeLoadHardening,
    "speculatable"                => Attribute::Speculatable,
    "ssp"                         => Attribute::StackProtect,
    "sspreq"                      => Attribute::StackProtectReq,
    "sspstrong"                   => Attribute::StackProtectStrong,
    "strictfp"                    => Attribute::StrictFP,
    "uwtable"                     => Attribute::UWTable,
};

// Etc

StringLiteral: String = {
    <s:r###"".*""###> => unescape(s.trim_matches('"')).unwrap(),
};

CommaAlign: u32 = {
    "," "align" <n:r"[0-9]+"> => n.parse().unwrap(),
}

match {
    // Ignore `; comments`
    r";[^\n\r]*[\n\r]*" => { },
} else {
    r"\s*" => { },
    _ // Everything else
}
